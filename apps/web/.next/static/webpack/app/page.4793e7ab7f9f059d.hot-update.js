"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   completeSession: function() { return /* binding */ completeSession; },\n/* harmony export */   getCurrentSession: function() { return /* binding */ getCurrentSession; },\n/* harmony export */   getPlayerData: function() { return /* binding */ getPlayerData; },\n/* harmony export */   startSession: function() { return /* binding */ startSession; },\n/* harmony export */   testApi: function() { return /* binding */ testApi; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n/**\r\n * Get the current user's session token for API calls\r\n */ async function getAuthToken() {\n    console.log(\"API: Getting auth token...\");\n    try {\n        // Check if Supabase is properly configured\n        if (false) {}\n        // Add timeout to prevent hanging\n        const timeoutPromise = new Promise((_, reject)=>{\n            setTimeout(()=>reject(new Error(\"Auth timeout\")), 5000); // 5 second timeout\n        });\n        console.log(\"API: About to call supabase.auth.getSession()...\");\n        const sessionPromise = _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getSession();\n        const { data: { session }, error } = await Promise.race([\n            sessionPromise,\n            timeoutPromise\n        ]);\n        if (error) {\n            console.error(\"API: Supabase auth error:\", error);\n            return \"mock-token-for-development\";\n        }\n        console.log(\"API: supabase.auth.getSession() completed\");\n        console.log(\"API: Session data:\", {\n            hasSession: !!session,\n            hasToken: !!(session === null || session === void 0 ? void 0 : session.access_token)\n        });\n        if (!(session === null || session === void 0 ? void 0 : session.access_token)) {\n            console.log(\"API: No session token, using mock token\");\n            return \"mock-token-for-development\";\n        }\n        console.log(\"API: Returning token, length:\", session.access_token.length);\n        return session.access_token;\n    } catch (error) {\n        console.error(\"API: Error in getAuthToken:\", error);\n        // Return a mock token for development\n        return \"mock-token-for-development\";\n    }\n}\n/**\r\n * Make an authenticated API request\r\n */ async function apiRequest(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    console.log(\"API: Making request to:\", endpoint);\n    const token = await getAuthToken();\n    console.log(\"API: Got token, length:\", token.length);\n    const controller = new AbortController();\n    const timeoutId = setTimeout(()=>{\n        console.log(\"API: Request timeout, aborting...\");\n        controller.abort();\n    }, 15000); // 15 second timeout\n    try {\n        console.log(\"API: Making fetch request...\");\n        const response = await fetch(\"/api\".concat(endpoint), {\n            ...options,\n            signal: controller.signal,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": \"Bearer \".concat(token),\n                ...options.headers\n            }\n        });\n        clearTimeout(timeoutId);\n        console.log(\"API: Fetch request completed\");\n        console.log(\"API: Response status:\", response.status);\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            console.error(\"API: Request failed:\", errorData);\n            throw new Error(errorData.error || \"API request failed: \".concat(response.status));\n        }\n        const data = await response.json();\n        console.log(\"API: Request successful, data:\", data);\n        return data;\n    } catch (error) {\n        clearTimeout(timeoutId);\n        if (error.name === \"AbortError\") {\n            console.error(\"API: Request timed out\");\n            throw new Error(\"Request timed out\");\n        }\n        throw error;\n    }\n}\n/**\r\n * Test API connectivity\r\n */ async function testApi() {\n    console.log(\"API: testApi called\");\n    try {\n        const response = await fetch(\"/api/test\", {\n            method: \"GET\"\n        });\n        console.log(\"API: testApi response status:\", response.status);\n        const data = await response.json();\n        console.log(\"API: testApi response data:\", data);\n        return data;\n    } catch (error) {\n        console.error(\"API: testApi error:\", error);\n        throw error;\n    }\n}\n/**\r\n * Start a new focus session\r\n */ async function startSession(request) {\n    console.log(\"API: startSession called with:\", request);\n    try {\n        const response = await apiRequest(\"/sessions/start\", {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n        console.log(\"API: startSession response:\", response);\n        return response;\n    } catch (error) {\n        console.error(\"API: startSession error:\", error);\n        throw error;\n    }\n}\n/**\r\n * Complete a focus session\r\n */ async function completeSession(request) {\n    return apiRequest(\"/sessions/complete\", {\n        method: \"POST\",\n        body: JSON.stringify(request)\n    });\n}\n/**\r\n * Get current user's active session\r\n */ async function getCurrentSession() {\n    try {\n        const token = await getAuthToken();\n        if (!token) return null;\n        const { data: { user } } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) return null;\n        const { data: session } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"sessions\").select(\"*\").eq(\"user_id\", user.id).is(\"ended_at\", null).order(\"started_at\", {\n            ascending: false\n        }).limit(1).single();\n        return session;\n    } catch (error) {\n        console.error(\"API: Failed to get current session:\", error);\n        return null;\n    }\n}\n/**\r\n * Get current user's player data\r\n */ async function getPlayerData() {\n    try {\n        var _profileResult_data;\n        const { data: { user } } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) return null;\n        // Get player data and profile data in parallel\n        const [playerResult, profileResult] = await Promise.all([\n            _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"players\").select(\"*\").eq(\"user_id\", user.id).single(),\n            _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").select(\"display_name\").eq(\"user_id\", user.id).single()\n        ]);\n        if (playerResult.error) {\n            throw playerResult.error;\n        }\n        // Combine player data with display name\n        const player = {\n            ...playerResult.data,\n            display_name: ((_profileResult_data = profileResult.data) === null || _profileResult_data === void 0 ? void 0 : _profileResult_data.display_name) || \"Adventurer\"\n        };\n        return player;\n    } catch (error) {\n        console.error(\"API: Failed to get player data:\", error);\n        // Return mock data for development\n        return {\n            id: \"mock-player-id\",\n            user_id: \"mock-user-id\",\n            level: 1,\n            xp: 0,\n            coins: 3,\n            sparks: 0,\n            is_inspired: false,\n            bond_score: 50,\n            mood_state: \"Happy\",\n            day_streak: 0,\n            created_at: new Date().toISOString(),\n            display_name: \"Adventurer\"\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RCxjQUFjSixFQUFBQSxzQkFBQUEsY0FBY2hELElBQUksY0FBbEJnRCwwQ0FBQUEsb0JBQW9CSSxZQUFZLEtBQUk7UUFDcEQ7UUFFQSxPQUFPRDtJQUNULEVBQUUsT0FBT2pELE9BQU87UUFDZGhCLFFBQVFnQixLQUFLLENBQUMsbUNBQW1DQTtRQUNqRCxtQ0FBbUM7UUFDbkMsT0FBTztZQUNMdUMsSUFBSTtZQUNKWSxTQUFTO1lBQ1RDLE9BQU87WUFDUEMsSUFBSTtZQUNKQyxPQUFPO1lBQ1BDLFFBQVE7WUFDUkMsYUFBYTtZQUNiQyxZQUFZO1lBQ1pDLFlBQVk7WUFDWkMsWUFBWTtZQUNaQyxZQUFZLElBQUlDLE9BQU9DLFdBQVc7WUFDbENaLGNBQWM7UUFDaEI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGkudHM/NjhhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJy4vc3VwYWJhc2UnO1xyXG5pbXBvcnQgeyBTdGFydFNlc3Npb25SZXF1ZXN0LCBTdGFydFNlc3Npb25SZXNwb25zZSwgQ29tcGxldGVTZXNzaW9uUmVxdWVzdCwgQ29tcGxldGVTZXNzaW9uUmVzcG9uc2UgfSBmcm9tICdAZGVmZWF0LXRoZS1kcmFnb24vZW5naW5lJztcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgdXNlcidzIHNlc3Npb24gdG9rZW4gZm9yIEFQSSBjYWxsc1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFRva2VuKCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gIGNvbnNvbGUubG9nKCdBUEk6IEdldHRpbmcgYXV0aCB0b2tlbi4uLicpO1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBpZiBTdXBhYmFzZSBpcyBwcm9wZXJseSBjb25maWd1cmVkXHJcbiAgICBpZiAoIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgPT09ICdodHRwczovL3BsYWNlaG9sZGVyLnN1cGFiYXNlLmNvJykge1xyXG4gICAgICBjb25zb2xlLmxvZygnQVBJOiBTdXBhYmFzZSBub3QgY29uZmlndXJlZCwgdXNpbmcgbW9jayB0b2tlbicpO1xyXG4gICAgICByZXR1cm4gJ21vY2stdG9rZW4tZm9yLWRldmVsb3BtZW50JztcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGltZW91dCB0byBwcmV2ZW50IGhhbmdpbmdcclxuICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0F1dGggdGltZW91dCcpKSwgNTAwMCk7IC8vIDUgc2Vjb25kIHRpbWVvdXRcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdBUEk6IEFib3V0IHRvIGNhbGwgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCkuLi4nKTtcclxuICAgIGNvbnN0IHNlc3Npb25Qcm9taXNlID0gc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCk7XHJcbiAgICBcclxuICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yIH0gPSBhd2FpdCBQcm9taXNlLnJhY2UoW3Nlc3Npb25Qcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pIGFzIGFueTtcclxuICAgIFxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSTogU3VwYWJhc2UgYXV0aCBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiAnbW9jay10b2tlbi1mb3ItZGV2ZWxvcG1lbnQnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnQVBJOiBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKSBjb21wbGV0ZWQnKTtcclxuICAgIGNvbnNvbGUubG9nKCdBUEk6IFNlc3Npb24gZGF0YTonLCB7IGhhc1Nlc3Npb246ICEhc2Vzc2lvbiwgaGFzVG9rZW46ICEhc2Vzc2lvbj8uYWNjZXNzX3Rva2VuIH0pO1xyXG4gICAgXHJcbiAgICBpZiAoIXNlc3Npb24/LmFjY2Vzc190b2tlbikge1xyXG4gICAgICBjb25zb2xlLmxvZygnQVBJOiBObyBzZXNzaW9uIHRva2VuLCB1c2luZyBtb2NrIHRva2VuJyk7XHJcbiAgICAgIHJldHVybiAnbW9jay10b2tlbi1mb3ItZGV2ZWxvcG1lbnQnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnQVBJOiBSZXR1cm5pbmcgdG9rZW4sIGxlbmd0aDonLCBzZXNzaW9uLmFjY2Vzc190b2tlbi5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIHNlc3Npb24uYWNjZXNzX3Rva2VuO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdBUEk6IEVycm9yIGluIGdldEF1dGhUb2tlbjonLCBlcnJvcik7XHJcbiAgICAvLyBSZXR1cm4gYSBtb2NrIHRva2VuIGZvciBkZXZlbG9wbWVudFxyXG4gICAgcmV0dXJuICdtb2NrLXRva2VuLWZvci1kZXZlbG9wbWVudCc7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogTWFrZSBhbiBhdXRoZW50aWNhdGVkIEFQSSByZXF1ZXN0XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBhcGlSZXF1ZXN0PFQ+KFxyXG4gIGVuZHBvaW50OiBzdHJpbmcsIFxyXG4gIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge31cclxuKTogUHJvbWlzZTxUPiB7XHJcbiAgY29uc29sZS5sb2coJ0FQSTogTWFraW5nIHJlcXVlc3QgdG86JywgZW5kcG9pbnQpO1xyXG4gIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0QXV0aFRva2VuKCk7XHJcbiAgY29uc29sZS5sb2coJ0FQSTogR290IHRva2VuLCBsZW5ndGg6JywgdG9rZW4ubGVuZ3RoKTtcclxuXHJcbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCdBUEk6IFJlcXVlc3QgdGltZW91dCwgYWJvcnRpbmcuLi4nKTtcclxuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcclxuICB9LCAxNTAwMCk7IC8vIDE1IHNlY29uZCB0aW1lb3V0XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZygnQVBJOiBNYWtpbmcgZmV0Y2ggcmVxdWVzdC4uLicpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaSR7ZW5kcG9pbnR9YCwge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG4gICAgY29uc29sZS5sb2coJ0FQSTogRmV0Y2ggcmVxdWVzdCBjb21wbGV0ZWQnKTtcclxuXHJcbiAgY29uc29sZS5sb2coJ0FQSTogUmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XHJcblxyXG4gIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0FQSTogUmVxdWVzdCBmYWlsZWQ6JywgZXJyb3JEYXRhKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgYEFQSSByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gIGNvbnNvbGUubG9nKCdBUEk6IFJlcXVlc3Qgc3VjY2Vzc2Z1bCwgZGF0YTonLCBkYXRhKTtcclxuICByZXR1cm4gZGF0YTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XHJcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSTogUmVxdWVzdCB0aW1lZCBvdXQnKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IHRpbWVkIG91dCcpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGVzdCBBUEkgY29ubmVjdGl2aXR5XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGVzdEFwaSgpOiBQcm9taXNlPGFueT4ge1xyXG4gIGNvbnNvbGUubG9nKCdBUEk6IHRlc3RBcGkgY2FsbGVkJyk7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvdGVzdCcsIHtcclxuICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coJ0FQSTogdGVzdEFwaSByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zb2xlLmxvZygnQVBJOiB0ZXN0QXBpIHJlc3BvbnNlIGRhdGE6JywgZGF0YSk7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignQVBJOiB0ZXN0QXBpIGVycm9yOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFN0YXJ0IGEgbmV3IGZvY3VzIHNlc3Npb25cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydFNlc3Npb24ocmVxdWVzdDogU3RhcnRTZXNzaW9uUmVxdWVzdCk6IFByb21pc2U8U3RhcnRTZXNzaW9uUmVzcG9uc2U+IHtcclxuICBjb25zb2xlLmxvZygnQVBJOiBzdGFydFNlc3Npb24gY2FsbGVkIHdpdGg6JywgcmVxdWVzdCk7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdDxTdGFydFNlc3Npb25SZXNwb25zZT4oJy9zZXNzaW9ucy9zdGFydCcsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZygnQVBJOiBzdGFydFNlc3Npb24gcmVzcG9uc2U6JywgcmVzcG9uc2UpO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdBUEk6IHN0YXJ0U2Vzc2lvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wbGV0ZSBhIGZvY3VzIHNlc3Npb25cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21wbGV0ZVNlc3Npb24ocmVxdWVzdDogQ29tcGxldGVTZXNzaW9uUmVxdWVzdCk6IFByb21pc2U8Q29tcGxldGVTZXNzaW9uUmVzcG9uc2U+IHtcclxuICByZXR1cm4gYXBpUmVxdWVzdDxDb21wbGV0ZVNlc3Npb25SZXNwb25zZT4oJy9zZXNzaW9ucy9jb21wbGV0ZScsIHtcclxuICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksXHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgY3VycmVudCB1c2VyJ3MgYWN0aXZlIHNlc3Npb25cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDdXJyZW50U2Vzc2lvbigpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCBnZXRBdXRoVG9rZW4oKTtcclxuICAgIGlmICghdG9rZW4pIHJldHVybiBudWxsO1xyXG5cclxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xyXG4gICAgaWYgKCF1c2VyKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjb25zdCB7IGRhdGE6IHNlc3Npb24gfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdzZXNzaW9ucycpXHJcbiAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxyXG4gICAgICAuaXMoJ2VuZGVkX2F0JywgbnVsbClcclxuICAgICAgLm9yZGVyKCdzdGFydGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcbiAgICAgIC5saW1pdCgxKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgcmV0dXJuIHNlc3Npb247XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0FQSTogRmFpbGVkIHRvIGdldCBjdXJyZW50IHNlc3Npb246JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGN1cnJlbnQgdXNlcidzIHBsYXllciBkYXRhXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGxheWVyRGF0YSgpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XHJcbiAgICBpZiAoIXVzZXIpIHJldHVybiBudWxsO1xyXG5cclxuICAgIC8vIEdldCBwbGF5ZXIgZGF0YSBhbmQgcHJvZmlsZSBkYXRhIGluIHBhcmFsbGVsXHJcbiAgICBjb25zdCBbcGxheWVyUmVzdWx0LCBwcm9maWxlUmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgncGxheWVycycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcclxuICAgICAgICAuc2luZ2xlKCksXHJcbiAgICAgIHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcclxuICAgICAgICAuc2VsZWN0KCdkaXNwbGF5X25hbWUnKVxyXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXHJcbiAgICAgICAgLnNpbmdsZSgpXHJcbiAgICBdKTtcclxuXHJcbiAgICBpZiAocGxheWVyUmVzdWx0LmVycm9yKSB7XHJcbiAgICAgIHRocm93IHBsYXllclJlc3VsdC5lcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21iaW5lIHBsYXllciBkYXRhIHdpdGggZGlzcGxheSBuYW1lXHJcbiAgICBjb25zdCBwbGF5ZXIgPSB7XHJcbiAgICAgIC4uLnBsYXllclJlc3VsdC5kYXRhLFxyXG4gICAgICBkaXNwbGF5X25hbWU6IHByb2ZpbGVSZXN1bHQuZGF0YT8uZGlzcGxheV9uYW1lIHx8ICdBZHZlbnR1cmVyJ1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gcGxheWVyO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdBUEk6IEZhaWxlZCB0byBnZXQgcGxheWVyIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgLy8gUmV0dXJuIG1vY2sgZGF0YSBmb3IgZGV2ZWxvcG1lbnRcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiAnbW9jay1wbGF5ZXItaWQnLFxyXG4gICAgICB1c2VyX2lkOiAnbW9jay11c2VyLWlkJyxcclxuICAgICAgbGV2ZWw6IDEsXHJcbiAgICAgIHhwOiAwLFxyXG4gICAgICBjb2luczogMyxcclxuICAgICAgc3BhcmtzOiAwLFxyXG4gICAgICBpc19pbnNwaXJlZDogZmFsc2UsXHJcbiAgICAgIGJvbmRfc2NvcmU6IDUwLFxyXG4gICAgICBtb29kX3N0YXRlOiAnSGFwcHknLFxyXG4gICAgICBkYXlfc3RyZWFrOiAwLFxyXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIGRpc3BsYXlfbmFtZTogJ0FkdmVudHVyZXInXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJnZXRBdXRoVG9rZW4iLCJjb25zb2xlIiwibG9nIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInRpbWVvdXRQcm9taXNlIiwiUHJvbWlzZSIsIl8iLCJyZWplY3QiLCJzZXRUaW1lb3V0IiwiRXJyb3IiLCJzZXNzaW9uUHJvbWlzZSIsImF1dGgiLCJnZXRTZXNzaW9uIiwiZGF0YSIsInNlc3Npb24iLCJlcnJvciIsInJhY2UiLCJoYXNTZXNzaW9uIiwiaGFzVG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJsZW5ndGgiLCJhcGlSZXF1ZXN0IiwiZW5kcG9pbnQiLCJvcHRpb25zIiwidG9rZW4iLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwiYWJvcnQiLCJyZXNwb25zZSIsImZldGNoIiwic2lnbmFsIiwiaGVhZGVycyIsImNsZWFyVGltZW91dCIsInN0YXR1cyIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsImNhdGNoIiwibmFtZSIsInRlc3RBcGkiLCJtZXRob2QiLCJzdGFydFNlc3Npb24iLCJyZXF1ZXN0IiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb21wbGV0ZVNlc3Npb24iLCJnZXRDdXJyZW50U2Vzc2lvbiIsInVzZXIiLCJnZXRVc2VyIiwiZnJvbSIsInNlbGVjdCIsImVxIiwiaWQiLCJpcyIsIm9yZGVyIiwiYXNjZW5kaW5nIiwibGltaXQiLCJzaW5nbGUiLCJnZXRQbGF5ZXJEYXRhIiwicHJvZmlsZVJlc3VsdCIsInBsYXllclJlc3VsdCIsImFsbCIsInBsYXllciIsImRpc3BsYXlfbmFtZSIsInVzZXJfaWQiLCJsZXZlbCIsInhwIiwiY29pbnMiLCJzcGFya3MiLCJpc19pbnNwaXJlZCIsImJvbmRfc2NvcmUiLCJtb29kX3N0YXRlIiwiZGF5X3N0cmVhayIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});