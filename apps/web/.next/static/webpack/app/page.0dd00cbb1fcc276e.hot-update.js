"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   completeSession: function() { return /* binding */ completeSession; },\n/* harmony export */   getCurrentSession: function() { return /* binding */ getCurrentSession; },\n/* harmony export */   getPlayerData: function() { return /* binding */ getPlayerData; },\n/* harmony export */   startSession: function() { return /* binding */ startSession; },\n/* harmony export */   testApi: function() { return /* binding */ testApi; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n/**\r\n * Get the current user's session token for API calls\r\n */ async function getAuthToken() {\n    console.log(\"API: Getting auth token...\");\n    try {\n        // Check if Supabase is properly configured\n        if (false) {}\n        console.log(\"API: About to call supabase.auth.getSession()...\");\n        const { data: { session }, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getSession();\n        if (error) {\n            console.error(\"API: Supabase auth error:\", error);\n            return \"mock-token-for-development\";\n        }\n        console.log(\"API: supabase.auth.getSession() completed\");\n        console.log(\"API: Session data:\", {\n            hasSession: !!session,\n            hasToken: !!(session === null || session === void 0 ? void 0 : session.access_token)\n        });\n        if (!(session === null || session === void 0 ? void 0 : session.access_token)) {\n            console.log(\"API: No session token, using mock token\");\n            return \"mock-token-for-development\";\n        }\n        console.log(\"API: Returning token, length:\", session.access_token.length);\n        return session.access_token;\n    } catch (error) {\n        console.error(\"API: Error in getAuthToken:\", error);\n        // Return a mock token for development\n        return \"mock-token-for-development\";\n    }\n}\n/**\r\n * Make an authenticated API request\r\n */ async function apiRequest(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    console.log(\"API: Making request to:\", endpoint);\n    const token = await getAuthToken();\n    console.log(\"API: Got token, length:\", token.length);\n    const controller = new AbortController();\n    const timeoutId = setTimeout(()=>{\n        console.log(\"API: Request timeout, aborting...\");\n        controller.abort();\n    }, 15000); // 15 second timeout\n    try {\n        console.log(\"API: Making fetch request...\");\n        const response = await fetch(\"/api\".concat(endpoint), {\n            ...options,\n            signal: controller.signal,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": \"Bearer \".concat(token),\n                ...options.headers\n            }\n        });\n        clearTimeout(timeoutId);\n        console.log(\"API: Fetch request completed\");\n        console.log(\"API: Response status:\", response.status);\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            console.error(\"API: Request failed:\", errorData);\n            throw new Error(errorData.error || \"API request failed: \".concat(response.status));\n        }\n        const data = await response.json();\n        console.log(\"API: Request successful, data:\", data);\n        return data;\n    } catch (error) {\n        clearTimeout(timeoutId);\n        if (error.name === \"AbortError\") {\n            console.error(\"API: Request timed out\");\n            throw new Error(\"Request timed out\");\n        }\n        throw error;\n    }\n}\n/**\r\n * Test API connectivity\r\n */ async function testApi() {\n    console.log(\"API: testApi called\");\n    try {\n        const response = await fetch(\"/api/test\", {\n            method: \"GET\"\n        });\n        console.log(\"API: testApi response status:\", response.status);\n        const data = await response.json();\n        console.log(\"API: testApi response data:\", data);\n        return data;\n    } catch (error) {\n        console.error(\"API: testApi error:\", error);\n        throw error;\n    }\n}\n/**\r\n * Start a new focus session\r\n */ async function startSession(request) {\n    console.log(\"API: startSession called with:\", request);\n    try {\n        const response = await apiRequest(\"/sessions/start\", {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n        console.log(\"API: startSession response:\", response);\n        return response;\n    } catch (error) {\n        console.error(\"API: startSession error:\", error);\n        throw error;\n    }\n}\n/**\r\n * Complete a focus session\r\n */ async function completeSession(request) {\n    return apiRequest(\"/sessions/complete\", {\n        method: \"POST\",\n        body: JSON.stringify(request)\n    });\n}\n/**\r\n * Get current user's active session\r\n */ async function getCurrentSession() {\n    try {\n        const token = await getAuthToken();\n        if (!token) return null;\n        const { data: { user } } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) return null;\n        const { data: session } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"sessions\").select(\"*\").eq(\"user_id\", user.id).is(\"ended_at\", null).order(\"started_at\", {\n            ascending: false\n        }).limit(1).single();\n        return session;\n    } catch (error) {\n        console.error(\"API: Failed to get current session:\", error);\n        return null;\n    }\n}\n/**\r\n * Get current user's player data\r\n */ async function getPlayerData() {\n    try {\n        var _profileResult_data;\n        const { data: { user } } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) return null;\n        // Get player data and profile data in parallel\n        const [playerResult, profileResult] = await Promise.all([\n            _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"players\").select(\"*\").eq(\"user_id\", user.id).single(),\n            _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").select(\"display_name\").eq(\"user_id\", user.id).single()\n        ]);\n        if (playerResult.error) {\n            throw playerResult.error;\n        }\n        // Combine player data with display name\n        const player = {\n            ...playerResult.data,\n            display_name: ((_profileResult_data = profileResult.data) === null || _profileResult_data === void 0 ? void 0 : _profileResult_data.display_name) || \"Adventurer\"\n        };\n        return player;\n    } catch (error) {\n        console.error(\"API: Failed to get player data:\", error);\n        // Return mock data for development\n        return {\n            id: \"mock-player-id\",\n            user_id: \"mock-user-id\",\n            level: 1,\n            xp: 0,\n            coins: 3,\n            sparks: 0,\n            is_inspired: false,\n            bond_score: 50,\n            mood_state: \"Happy\",\n            day_streak: 0,\n            created_at: new Date().toISOString(),\n            display_name: \"Adventurer\"\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q1RDLE9BQU87WUFDUEMsSUFBSTtZQUNKQyxPQUFPO1lBQ1BDLFFBQVE7WUFDUkMsYUFBYTtZQUNiQyxZQUFZO1lBQ1pDLFlBQVk7WUFDWkMsWUFBWTtZQUNaQyxZQUFZLElBQUlDLE9BQU9DLFdBQVc7WUFDbENaLGNBQWM7UUFDaEI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGkudHM/NjhhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJy4vc3VwYWJhc2UnO1xyXG5pbXBvcnQgeyBTdGFydFNlc3Npb25SZXF1ZXN0LCBTdGFydFNlc3Npb25SZXNwb25zZSwgQ29tcGxldGVTZXNzaW9uUmVxdWVzdCwgQ29tcGxldGVTZXNzaW9uUmVzcG9uc2UgfSBmcm9tICdAZGVmZWF0LXRoZS1kcmFnb24vZW5naW5lJztcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgdXNlcidzIHNlc3Npb24gdG9rZW4gZm9yIEFQSSBjYWxsc1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFRva2VuKCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gIGNvbnNvbGUubG9nKCdBUEk6IEdldHRpbmcgYXV0aCB0b2tlbi4uLicpO1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBpZiBTdXBhYmFzZSBpcyBwcm9wZXJseSBjb25maWd1cmVkXHJcbiAgICBpZiAoIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgPT09ICdodHRwczovL3BsYWNlaG9sZGVyLnN1cGFiYXNlLmNvJykge1xyXG4gICAgICBjb25zb2xlLmxvZygnQVBJOiBTdXBhYmFzZSBub3QgY29uZmlndXJlZCwgdXNpbmcgbW9jayB0b2tlbicpO1xyXG4gICAgICByZXR1cm4gJ21vY2stdG9rZW4tZm9yLWRldmVsb3BtZW50JztcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZygnQVBJOiBBYm91dCB0byBjYWxsIHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpLi4uJyk7XHJcbiAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCk7XHJcbiAgICBcclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEk6IFN1cGFiYXNlIGF1dGggZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gJ21vY2stdG9rZW4tZm9yLWRldmVsb3BtZW50JztcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0FQSTogc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCkgY29tcGxldGVkJyk7XHJcbiAgICBjb25zb2xlLmxvZygnQVBJOiBTZXNzaW9uIGRhdGE6JywgeyBoYXNTZXNzaW9uOiAhIXNlc3Npb24sIGhhc1Rva2VuOiAhIXNlc3Npb24/LmFjY2Vzc190b2tlbiB9KTtcclxuICAgIFxyXG4gICAgaWYgKCFzZXNzaW9uPy5hY2Nlc3NfdG9rZW4pIHtcclxuICAgICAgY29uc29sZS5sb2coJ0FQSTogTm8gc2Vzc2lvbiB0b2tlbiwgdXNpbmcgbW9jayB0b2tlbicpO1xyXG4gICAgICByZXR1cm4gJ21vY2stdG9rZW4tZm9yLWRldmVsb3BtZW50JztcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0FQSTogUmV0dXJuaW5nIHRva2VuLCBsZW5ndGg6Jywgc2Vzc2lvbi5hY2Nlc3NfdG9rZW4ubGVuZ3RoKTtcclxuICAgIHJldHVybiBzZXNzaW9uLmFjY2Vzc190b2tlbjtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignQVBJOiBFcnJvciBpbiBnZXRBdXRoVG9rZW46JywgZXJyb3IpO1xyXG4gICAgLy8gUmV0dXJuIGEgbW9jayB0b2tlbiBmb3IgZGV2ZWxvcG1lbnRcclxuICAgIHJldHVybiAnbW9jay10b2tlbi1mb3ItZGV2ZWxvcG1lbnQnO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE1ha2UgYW4gYXV0aGVudGljYXRlZCBBUEkgcmVxdWVzdFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gYXBpUmVxdWVzdDxUPihcclxuICBlbmRwb2ludDogc3RyaW5nLCBcclxuICBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9XHJcbik6IFByb21pc2U8VD4ge1xyXG4gIGNvbnNvbGUubG9nKCdBUEk6IE1ha2luZyByZXF1ZXN0IHRvOicsIGVuZHBvaW50KTtcclxuICBjb25zdCB0b2tlbiA9IGF3YWl0IGdldEF1dGhUb2tlbigpO1xyXG4gIGNvbnNvbGUubG9nKCdBUEk6IEdvdCB0b2tlbiwgbGVuZ3RoOicsIHRva2VuLmxlbmd0aCk7XHJcblxyXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygnQVBJOiBSZXF1ZXN0IHRpbWVvdXQsIGFib3J0aW5nLi4uJyk7XHJcbiAgICBjb250cm9sbGVyLmFib3J0KCk7XHJcbiAgfSwgMTUwMDApOyAvLyAxNSBzZWNvbmQgdGltZW91dFxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coJ0FQSTogTWFraW5nIGZldGNoIHJlcXVlc3QuLi4nKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkke2VuZHBvaW50fWAsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuICAgIGNvbnNvbGUubG9nKCdBUEk6IEZldGNoIHJlcXVlc3QgY29tcGxldGVkJyk7XHJcblxyXG4gIGNvbnNvbGUubG9nKCdBUEk6IFJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xyXG5cclxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XHJcbiAgICBjb25zb2xlLmVycm9yKCdBUEk6IFJlcXVlc3QgZmFpbGVkOicsIGVycm9yRGF0YSk7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGBBUEkgcmVxdWVzdCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICBjb25zb2xlLmxvZygnQVBJOiBSZXF1ZXN0IHN1Y2Nlc3NmdWwsIGRhdGE6JywgZGF0YSk7XHJcbiAgcmV0dXJuIGRhdGE7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEk6IFJlcXVlc3QgdGltZWQgb3V0Jyk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCB0aW1lZCBvdXQnKTtcclxuICAgIH1cclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3QgQVBJIGNvbm5lY3Rpdml0eVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRlc3RBcGkoKTogUHJvbWlzZTxhbnk+IHtcclxuICBjb25zb2xlLmxvZygnQVBJOiB0ZXN0QXBpIGNhbGxlZCcpO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Rlc3QnLCB7XHJcbiAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKCdBUEk6IHRlc3RBcGkgcmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5sb2coJ0FQSTogdGVzdEFwaSByZXNwb25zZSBkYXRhOicsIGRhdGEpO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0FQSTogdGVzdEFwaSBlcnJvcjonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGFydCBhIG5ldyBmb2N1cyBzZXNzaW9uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnRTZXNzaW9uKHJlcXVlc3Q6IFN0YXJ0U2Vzc2lvblJlcXVlc3QpOiBQcm9taXNlPFN0YXJ0U2Vzc2lvblJlc3BvbnNlPiB7XHJcbiAgY29uc29sZS5sb2coJ0FQSTogc3RhcnRTZXNzaW9uIGNhbGxlZCB3aXRoOicsIHJlcXVlc3QpO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVJlcXVlc3Q8U3RhcnRTZXNzaW9uUmVzcG9uc2U+KCcvc2Vzc2lvbnMvc3RhcnQnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coJ0FQSTogc3RhcnRTZXNzaW9uIHJlc3BvbnNlOicsIHJlc3BvbnNlKTtcclxuICAgIHJldHVybiByZXNwb25zZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignQVBJOiBzdGFydFNlc3Npb24gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29tcGxldGUgYSBmb2N1cyBzZXNzaW9uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29tcGxldGVTZXNzaW9uKHJlcXVlc3Q6IENvbXBsZXRlU2Vzc2lvblJlcXVlc3QpOiBQcm9taXNlPENvbXBsZXRlU2Vzc2lvblJlc3BvbnNlPiB7XHJcbiAgcmV0dXJuIGFwaVJlcXVlc3Q8Q29tcGxldGVTZXNzaW9uUmVzcG9uc2U+KCcvc2Vzc2lvbnMvY29tcGxldGUnLCB7XHJcbiAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGN1cnJlbnQgdXNlcidzIGFjdGl2ZSBzZXNzaW9uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFNlc3Npb24oKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0QXV0aFRva2VuKCk7XHJcbiAgICBpZiAoIXRva2VuKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcclxuICAgIGlmICghdXNlcikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnc2Vzc2lvbnMnKVxyXG4gICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcclxuICAgICAgLmlzKCdlbmRlZF9hdCcsIG51bGwpXHJcbiAgICAgIC5vcmRlcignc3RhcnRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gICAgICAubGltaXQoMSlcclxuICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgIHJldHVybiBzZXNzaW9uO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdBUEk6IEZhaWxlZCB0byBnZXQgY3VycmVudCBzZXNzaW9uOicsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBjdXJyZW50IHVzZXIncyBwbGF5ZXIgZGF0YVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBsYXllckRhdGEoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xyXG4gICAgaWYgKCF1c2VyKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAvLyBHZXQgcGxheWVyIGRhdGEgYW5kIHByb2ZpbGUgZGF0YSBpbiBwYXJhbGxlbFxyXG4gICAgY29uc3QgW3BsYXllclJlc3VsdCwgcHJvZmlsZVJlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgIHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3BsYXllcnMnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXHJcbiAgICAgICAgLnNpbmdsZSgpLFxyXG4gICAgICBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXHJcbiAgICAgICAgLnNlbGVjdCgnZGlzcGxheV9uYW1lJylcclxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG4gICAgXSk7XHJcblxyXG4gICAgaWYgKHBsYXllclJlc3VsdC5lcnJvcikge1xyXG4gICAgICB0aHJvdyBwbGF5ZXJSZXN1bHQuZXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tYmluZSBwbGF5ZXIgZGF0YSB3aXRoIGRpc3BsYXkgbmFtZVxyXG4gICAgY29uc3QgcGxheWVyID0ge1xyXG4gICAgICAuLi5wbGF5ZXJSZXN1bHQuZGF0YSxcclxuICAgICAgZGlzcGxheV9uYW1lOiBwcm9maWxlUmVzdWx0LmRhdGE/LmRpc3BsYXlfbmFtZSB8fCAnQWR2ZW50dXJlcidcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHBsYXllcjtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignQVBJOiBGYWlsZWQgdG8gZ2V0IHBsYXllciBkYXRhOicsIGVycm9yKTtcclxuICAgIC8vIFJldHVybiBtb2NrIGRhdGEgZm9yIGRldmVsb3BtZW50XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogJ21vY2stcGxheWVyLWlkJyxcclxuICAgICAgdXNlcl9pZDogJ21vY2stdXNlci1pZCcsXHJcbiAgICAgIGxldmVsOiAxLFxyXG4gICAgICB4cDogMCxcclxuICAgICAgY29pbnM6IDMsXHJcbiAgICAgIHNwYXJrczogMCxcclxuICAgICAgaXNfaW5zcGlyZWQ6IGZhbHNlLFxyXG4gICAgICBib25kX3Njb3JlOiA1MCxcclxuICAgICAgbW9vZF9zdGF0ZTogJ0hhcHB5JyxcclxuICAgICAgZGF5X3N0cmVhazogMCxcclxuICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBkaXNwbGF5X25hbWU6ICdBZHZlbnR1cmVyJ1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwiZ2V0QXV0aFRva2VuIiwiY29uc29sZSIsImxvZyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJkYXRhIiwic2Vzc2lvbiIsImVycm9yIiwiYXV0aCIsImdldFNlc3Npb24iLCJoYXNTZXNzaW9uIiwiaGFzVG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJsZW5ndGgiLCJhcGlSZXF1ZXN0IiwiZW5kcG9pbnQiLCJvcHRpb25zIiwidG9rZW4iLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsInNpZ25hbCIsImhlYWRlcnMiLCJjbGVhclRpbWVvdXQiLCJzdGF0dXMiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsIkVycm9yIiwibmFtZSIsInRlc3RBcGkiLCJtZXRob2QiLCJzdGFydFNlc3Npb24iLCJyZXF1ZXN0IiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb21wbGV0ZVNlc3Npb24iLCJnZXRDdXJyZW50U2Vzc2lvbiIsInVzZXIiLCJnZXRVc2VyIiwiZnJvbSIsInNlbGVjdCIsImVxIiwiaWQiLCJpcyIsIm9yZGVyIiwiYXNjZW5kaW5nIiwibGltaXQiLCJzaW5nbGUiLCJnZXRQbGF5ZXJEYXRhIiwicHJvZmlsZVJlc3VsdCIsInBsYXllclJlc3VsdCIsIlByb21pc2UiLCJhbGwiLCJwbGF5ZXIiLCJkaXNwbGF5X25hbWUiLCJ1c2VyX2lkIiwibGV2ZWwiLCJ4cCIsImNvaW5zIiwic3BhcmtzIiwiaXNfaW5zcGlyZWQiLCJib25kX3Njb3JlIiwibW9vZF9zdGF0ZSIsImRheV9zdHJlYWsiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});